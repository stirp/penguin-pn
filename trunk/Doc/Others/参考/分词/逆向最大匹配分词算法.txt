逆向最大匹配分词算法

目前对中文分词有两个方向，其中一个是利用概率的思想对文章分词。也就是如果两个字，一起出现的频率很高的话，我们可以假设这两个字是一个词。这里可以用一个公式衡量：M(A,B)=P(AB)/P(A)P(B)，其中A表示一个字，B表示一个字，P(AB)表示AB相邻出现的概率，P(A)表示A在这篇文章中的频度，P(B)表示B在这篇文章中的频度。用概率分词的好处是不需要借助词典的帮助，坏处是算法比较麻烦，效率不高，也存在一定的出错率。
另外的一个方向是使用词典分词。就是事先为程序准备一个词典，然后通过这个词典对文章分词。目前较流行的方式有正向最大匹配算法和逆向最大匹配算法。逆向最大匹配算法在准确性上要更好一些。

以 “我是一个坏人” 为例

正向的顺序为
我是一
我是
我 ===> 得到一个词
是一个
是一
是 ===>得到一个词
一个坏
一个===> 得到一个词
坏人===>得到一个词
结果 我、是、一个、坏人

反向算法
个坏人
坏人==> 坏人
是一个
一个==> 一个
我是
是==> 是
我==> 我
结果 我、是、一个、坏人

逆向最大匹配：
(1)将文章分成句子(通过标点符号来实现)；
(2)循环的读入每一个句子S，设句子中的字数为n；
(3)设置一个最大词长度，就是我们要截取的词的最大长度max；
(4)从句子中取n-max到n的字符串subword，去字典中查找是否有这个词。
如果有就走(5),没有就走(6)；
(5)记住subword，从n-max付值给n，继续执行(4)，直到n=0。
(6)将max-1，再执行(4)。

伪代码如下：
max=4;
for(i..N){
　　　sentence = 读入下一个句子；
　n = 取字数(sentence)；
for(j=n;j>0;){
subword = 截取字符串(j-max,j)；
flag=去字典中查找(subword);
if(flag){//找到这个词
记住(subword);
j=n-max;
}else{
for(k=max;k>0;k--){
tempWord=截取字符串(subword.length-max,subword.length，subword)
temFlg=去字典中查找(subword);
if(temFlg)break;
}
记住(tempWord)
j=n-max+k;
}
}
}



本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/duck_genuine/archive/2010/05/28/5630647.aspx